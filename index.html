<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Nexus</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåÄ</text></svg>">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Orbitron', monospace;
            background: radial-gradient(circle at 30% 20%, #1a0033 0%, #000011 50%, #000000 100%);
            overflow: hidden;
            height: 100vh;
            color: #ffffff;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.8), rgba(0, 0, 20, 0.9));
            backdrop-filter: blur(10px);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2), inset 0 0 50px rgba(0, 100, 200, 0.1);
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 100;
        }

        .stat-panel {
            background: rgba(0, 20, 40, 0.8);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 15px 20px;
            min-width: 200px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
            font-weight: 700;
        }

        .stat-value {
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .quantum-meter {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .quantum-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0080, #00ffff, #80ff00);
            border-radius: 4px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .ability-panel {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .ability-btn {
            width: 50px;
            height: 50px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 12px;
            background: rgba(0, 20, 40, 0.6);
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #00ffff;
        }

        .ability-btn:hover {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transform: scale(1.1);
        }

        .ability-btn.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .menu-title {
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(45deg, #ff0080, #00ffff, #80ff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            animation: titlePulse 2s ease-in-out infinite alternate;
        }

        @keyframes titlePulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .menu-btn {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 700;
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            background: rgba(0, 20, 40, 0.6);
            backdrop-filter: blur(10px);
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            min-width: 250px;
            text-align: center;
        }

        .menu-btn:hover {
            border-color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            transform: translateY(-5px);
            background: rgba(0, 255, 255, 0.1);
        }

        .difficulty-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .difficulty-card {
            padding: 20px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            background: rgba(0, 20, 40, 0.4);
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            min-width: 180px;
        }

        .difficulty-card:hover {
            border-color: #00ffff;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.4);
            transform: scale(1.05);
        }

        .difficulty-card.selected {
            border-color: #80ff00;
            box-shadow: 0 0 25px rgba(128, 255, 0, 0.6);
        }

        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.9);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 20px;
            padding: 30px 40px;
            text-align: center;
            z-index: 2000;
            opacity: 0;
            scale: 0.8;
            transition: all 0.4s ease;
        }

        .notification.show {
            opacity: 1;
            scale: 1;
        }

        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.8);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 15px 20px;
            font-size: 12px;
            color: #00ffff;
        }

        .particle-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        @media (max-width: 768px) {
            .menu-title { font-size: 2.5rem; }
            .hud { flex-direction: column; gap: 10px; }
            .stat-panel { min-width: auto; width: 100%; }
            .difficulty-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <canvas class="particle-bg" id="backgroundCanvas"></canvas>
    
    <div class="game-container">
        <div class="hud">
            <div class="stat-panel">
                <div class="stat-item">
                    <span>SCORE</span>
                    <span class="stat-value" id="scoreDisplay">0</span>
                </div>
                <div class="stat-item">
                    <span>LEVEL</span>
                    <span class="stat-value" id="levelDisplay">1</span>
                </div>
                <div class="stat-item">
                    <span>QUANTUM ENERGY</span>
                    <span class="stat-value" id="energyDisplay">100%</span>
                </div>
                <div class="quantum-meter">
                    <div class="quantum-fill" id="quantumFill"></div>
                </div>
                <div class="stat-item">
                    <span>COHERENCE</span>
                    <span class="stat-value" id="coherenceDisplay">100%</span>
                </div>
            </div>
            
            <div class="stat-panel">
                <div style="text-align: center; margin-bottom: 10px; color: #00ffff; font-weight: 700;">QUANTUM ABILITIES</div>
                <div class="ability-panel">
                    <div class="ability-btn" id="teleportBtn" title="Quantum Tunneling [Q]">üåÄ</div>
                    <div class="ability-btn" id="slowTimeBtn" title="Time Dilation [W]">‚è∞</div>
                    <div class="ability-btn" id="shieldBtn" title="Quantum Shield [E]">üõ°Ô∏è</div>
                    <div class="ability-btn" id="cloneBtn" title="Superposition [R]">üë•</div>
                </div>
                <div class="ability-panel">
                    <div class="ability-btn" id="magnetBtn" title="Electromagnetic Field [T]">üß≤</div>
                    <div class="ability-btn" id="phaseBtn" title="Phase Shift [Y]">üåä</div>
                    <div class="ability-btn" id="entangleBtn" title="Quantum Entanglement [U]">üîó</div>
                    <div class="ability-btn" id="collapseBtn" title="Wave Function Collapse [I]">üí•</div>
                </div>
            </div>
        </div>

        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        
        <div class="controls-info">
            <div><strong>CONTROLS:</strong></div>
            <div>WASD/Arrows: Move | Mouse: Target | ESC: Pause</div>
            <div>Q: Teleport | W: Slow Time | E: Shield | R: Clone | T: Magnet | Y: Phase | U: Entangle | I: Collapse</div>
            <div>Reach the green target while avoiding red obstacles!</div>
        </div>
        
        <div class="menu-overlay" id="mainMenu">
            <div class="menu-title">QUANTUM NEXUS</div>
            <div class="menu-buttons">
                <button class="menu-btn" id="startBtn">START QUANTUM SIMULATION</button>
                <button class="menu-btn" id="difficultyBtn">DIFFICULTY MATRIX</button>
                <button class="menu-btn" id="tutorialBtn">TUTORIAL</button>
            </div>
        </div>

        <div class="menu-overlay" id="difficultyMenu" style="display: none;">
            <div class="menu-title">DIFFICULTY MATRIX</div>
            <div class="difficulty-grid">
                <div class="difficulty-card" data-difficulty="easy">
                    <h3 style="color: #80ff00; margin-bottom: 10px;">QUANTUM</h3>
                    <p>Perfect for beginners</p>
                    <p>Low complexity</p>
                </div>
                <div class="difficulty-card selected" data-difficulty="medium">
                    <h3 style="color: #00ffff; margin-bottom: 10px;">RELATIVISTIC</h3>
                    <p>Moderate challenge</p>
                    <p>Medium complexity</p>
                </div>
                <div class="difficulty-card" data-difficulty="hard">
                    <h3 style="color: #ff0080; margin-bottom: 10px;">SINGULARITY</h3>
                    <p>Extreme challenge</p>
                    <p>Maximum complexity</p>
                </div>
            </div>
            <button class="menu-btn" id="backBtn" style="margin-top: 30px;">RETURN TO MAIN MENU</button>
        </div>

        <div class="notification" id="notification">
            <h3 id="notificationTitle"></h3>
            <p id="notificationText"></p>
            <button class="menu-btn" id="notificationBtn">CONTINUE</button>
        </div>
    </div>

    <script>
        // Game Engine
        class QuantumGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.bgCanvas = document.getElementById('backgroundCanvas');
                this.bgCtx = this.bgCanvas.getContext('2d');
                
                this.setupCanvas();
                this.initGame();
                this.setupControls();
                this.createBackgroundParticles();
                this.startBackgroundAnimation();
            }

            setupCanvas() {
                const updateSize = () => {
                    const maxW = Math.min(window.innerWidth - 40, 1000);
                    const maxH = Math.min(window.innerHeight - 200, 700);
                    
                    this.canvas.width = maxW;
                    this.canvas.height = maxH;
                    this.bgCanvas.width = window.innerWidth;
                    this.bgCanvas.height = window.innerHeight;
                };
                updateSize();
                window.addEventListener('resize', updateSize);
            }

            initGame() {
                this.gameState = 'menu';
                this.difficulty = 'medium';
                this.score = 0;
                this.level = 1;
                this.quantumEnergy = 100;
                this.coherence = 100;
                this.timeScale = 1;
                
                this.player = {
                    x: 80, y: this.canvas.height / 2, vx: 0, vy: 0, radius: 12,
                    trail: [], wavePhase: 0, clones: []
                };
                
                this.target = {
                    x: this.canvas.width - 80, y: this.canvas.height / 2,
                    radius: 20, pulsePhase: 0, visible: true
                };
                
                this.obstacles = [];
                this.powerups = [];
                this.effects = [];
                this.backgroundParticles = [];
                
                this.abilities = {
                    teleport: { cd: 0, maxCd: 3000 },
                    slowTime: { cd: 0, maxCd: 5000, active: false, duration: 0 },
                    shield: { cd: 0, maxCd: 4000, active: false, duration: 0 },
                    clone: { cd: 0, maxCd: 6000 },
                    magnet: { cd: 0, maxCd: 3500, active: false, duration: 0 },
                    phase: { cd: 0, maxCd: 4500, active: false, duration: 0 },
                    entangle: { cd: 0, maxCd: 5500 },
                    collapse: { cd: 0, maxCd: 7000 }
                };
                
                this.keys = {};
                this.mouse = { x: 0, y: 0 };
                this.lastTime = performance.now();
                
                this.generateLevel();
            }

            generateLevel() {
                this.obstacles = [];
                this.powerups = [];
                
                const settings = {
                    easy: { obs: 3, pups: 3 },
                    medium: { obs: 5, pups: 2 },
                    hard: { obs: 8, pups: 1 }
                }[this.difficulty];
                
                const obsCount = settings.obs + Math.floor(this.level * 0.5);
                
                // Generate obstacles
                for (let i = 0; i < obsCount; i++) {
                    this.obstacles.push({
                        x: 200 + Math.random() * (this.canvas.width - 400),
                        y: 100 + Math.random() * (this.canvas.height - 200),
                        radius: 20 + Math.random() * 15,
                        type: ['blackhole', 'antimatter', 'vortex'][Math.floor(Math.random() * 3)],
                        rotation: 0,
                        pulsePhase: Math.random() * Math.PI * 2,
                        collapsing: false,
                        collapseTime: 1000
                    });
                }
                
                // Generate powerups
                for (let i = 0; i < settings.pups; i++) {
                    this.powerups.push({
                        x: 150 + Math.random() * (this.canvas.width - 300),
                        y: 150 + Math.random() * (this.canvas.height - 300),
                        radius: 15,
                        type: ['energy', 'shield', 'speed'][Math.floor(Math.random() * 3)],
                        rotation: 0,
                        pulsePhase: Math.random() * Math.PI * 2
                    });
                }
            }

            createBackgroundParticles() {
                this.backgroundParticles = [];
                for (let i = 0; i < 30; i++) {
                    this.backgroundParticles.push({
                        x: Math.random() * window.innerWidth,
                        y: Math.random() * window.innerHeight,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        size: Math.random() * 2 + 0.5,
                        opacity: Math.random() * 0.6 + 0.2,
                        hue: Math.random() * 360
                    });
                }
            }

            setupControls() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    if (this.gameState === 'playing') {
                        const abilities = { q: 'teleport', w: 'slowTime', e: 'shield', r: 'clone', t: 'magnet', y: 'phase', u: 'entangle', i: 'collapse' };
                        if (abilities[e.key.toLowerCase()]) this.activateAbility(abilities[e.key.toLowerCase()]);
                        if (e.key === 'Escape') this.togglePause();
                    }
                });
                
                window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false);
                
                // Mouse
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
                    this.mouse.y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
                });
                
                // Menu buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('difficultyBtn').addEventListener('click', () => this.showDifficultyMenu());
                document.getElementById('backBtn').addEventListener('click', () => this.showMainMenu());
                document.getElementById('tutorialBtn').addEventListener('click', () => this.showTutorial());
                
                // Difficulty selection
                document.querySelectorAll('.difficulty-card').forEach(card => {
                    card.addEventListener('click', () => {
                        document.querySelectorAll('.difficulty-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        this.difficulty = card.dataset.difficulty;
                    });
                });
                
                // Ability buttons
                const abilityBtns = ['teleport', 'slowTime', 'shield', 'clone', 'magnet', 'phase', 'entangle', 'collapse'];
                abilityBtns.forEach(ability => {
                    document.getElementById(ability + 'Btn').addEventListener('click', () => this.activateAbility(ability));
                });
                
                // Notification button
                document.getElementById('notificationBtn').addEventListener('click', () => {
                    document.getElementById('notification').classList.remove('show');
                    if (this.gameState === 'gameover') this.resetGame();
                    else if (this.gameState === 'levelcomplete') this.nextLevel();
                });
            }

            startGame() {
                this.gameState = 'playing';
                this.hideMenus();
                this.initGame();
                this.gameLoop();
            }

            showMainMenu() {
                document.getElementById('mainMenu').style.display = 'flex';
                document.getElementById('difficultyMenu').style.display = 'none';
            }

            showDifficultyMenu() {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('difficultyMenu').style.display = 'flex';
            }

            showTutorial() {
                this.showNotification('TUTORIAL', 'Use WASD or arrows to move your quantum particle. Avoid red obstacles and reach the green target. Use Q-W-E-R-T-Y-U-I for special abilities!');
            }

            hideMenus() {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('difficultyMenu').style.display = 'none';
            }

            activateAbility(ability) {
                if (this.gameState !== 'playing') return;
                
                const ab = this.abilities[ability];
                if (ab.cd > 0 || this.quantumEnergy < 25) return;
                
                this.quantumEnergy = Math.max(0, this.quantumEnergy - 25);
                ab.cd = ab.maxCd;
                
                switch (ability) {
                    case 'teleport':
                        this.player.x = this.mouse.x;
                        this.player.y = this.mouse.y;
                        this.createEffect('teleport', this.player.x, this.player.y);
                        break;
                    case 'slowTime':
                        this.timeScale = 0.3;
                        ab.active = true;
                        ab.duration = 2000;
                        break;
                    case 'shield':
                        ab.active = true;
                        ab.duration = 3000;
                        break;
                    case 'clone':
                        this.player.clones = [];
                        for (let i = 0; i < 3; i++) {
                            this.player.clones.push({
                                x: this.player.x + (Math.random() - 0.5) * 100,
                                y: this.player.y + (Math.random() - 0.5) * 100,
                                lifetime: 4000
                            });
                        }
                        break;
                    case 'magnet':
                        ab.active = true;
                        ab.duration = 3000;
                        break;
                    case 'phase':
                        ab.active = true;
                        ab.duration = 2500;
                        break;
                    case 'entangle':
                        this.createEffect('entangle', this.player.x, this.player.y);
                        break;
                    case 'collapse':
                        this.obstacles.forEach(obs => {
                            const dx = obs.x - this.player.x;
                            const dy = obs.y - this.player.y;
                            if (Math.sqrt(dx * dx + dy * dy) < 200) {
                                obs.collapsing = true;
                            }
                        });
                        this.createEffect('collapse', this.player.x, this.player.y);
                        break;
                }
                this.updateAbilityUI();
            }

            createEffect(type, x, y) {
                this.effects.push({
                    x, y, type, age: 0, maxAge: 1000,
                    particles: Array.from({ length: 10 }, () => ({
                        x, y,
                        vx: (Math.random() - 0.5) * 5,
                        vy: (Math.random() - 0.5) * 5,
                        size: Math.random() * 4 + 2,
                        alpha: 1
                    }))
                });
            }

            update(deltaTime) {
                if (this.gameState !== 'playing') return;
                
                const dt = deltaTime * this.timeScale;
                
                // Update player
                const speed = 0.4;
                if (this.keys['w'] || this.keys['arrowup']) this.player.vy -= speed;
                if (this.keys['s'] || this.keys['arrowdown']) this.player.vy += speed;
                if (this.keys['a'] || this.keys['arrowleft']) this.player.vx -= speed;
                if (this.keys['d'] || this.keys['arrowright']) this.player.vx += speed;
                
                this.player.vx *= 0.92;
                this.player.vy *= 0.92;
                
                // Quantum uncertainty (reduced for better control)
                const uncertainty = this.abilities.shield.active ? 0.2 : 0.8;
                this.player.x += (Math.random() - 0.5) * uncertainty;
                this.player.y += (Math.random() - 0.5) * uncertainty;
                
                this.player.x += this.player.vx * dt * 0.1;
                this.player.y += this.player.vy * dt * 0.1;
                
                // Keep in bounds
                this.player.x = Math.max(this.player.radius, Math.min(this.canvas.width - this.player.radius, this.player.x));
                this.player.y = Math.max(this.player.radius, Math.min(this.canvas.height - this.player.radius, this.player.y));
                
                // Update trail
                this.player.trail.push({ x: this.player.x, y: this.player.y, alpha: 1 });
                if (this.player.trail.length > 15) this.player.trail.shift();
                this.player.trail.forEach(point => point.alpha -= 0.07);
                
                this.player.wavePhase += dt * 0.01;
                
                // Update clones
                this.player.clones.forEach((clone, i) => {
                    clone.lifetime -= dt;
                    if (clone.lifetime <= 0) this.player.clones.splice(i, 1);
                });
                
                // Update obstacles
                this.obstacles.forEach((obs, i) => {
                    obs.rotation += dt * 0.002;
                    obs.pulsePhase += dt * 0.005;
                    if (obs.collapsing) {
                        obs.collapseTime -= dt;
                        obs.radius *= 0.99;
                        if (obs.collapseTime <= 0) this.obstacles.splice(i, 1);
                    }
                });
                
                // Update powerups
                this.powerups.forEach((pup, i) => {
                    pup.rotation += dt * 0.003;
                    pup.pulsePhase += dt * 0.008;
                    
                    // Magnet effect
                    if (this.abilities.magnet.active) {
                        const dx = this.player.x - pup.x;
                        const dy = this.player.y - pup.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 200 && dist > 0) {
                            pup.x += (dx / dist) * 2;
                            pup.y += (dy / dist) * 2;
                        }
                    }
                    
                    if (this.checkCollision(this.player, pup)) {
                        this.collectPowerup(pup);
                        this.powerups.splice(i, 1);
                    }
                });
                
                // Update target
                this.target.pulsePhase += dt * 0.01;
                if (Math.random() < 0.001) this.target.visible = Math.random() < 0.9;
                
                // Update abilities
                Object.keys(this.abilities).forEach(key => {
                    const ab = this.abilities[key];
                    if (ab.cd > 0) ab.cd = Math.max(0, ab.cd - dt);
                    if (ab.active && ab.duration !== undefined) {
                        ab.duration = Math.max(0, ab.duration - dt);
                        if (ab.duration === 0) {
                            ab.active = false;
                            if (key === 'slowTime') this.timeScale = 1;
                        }
                    }
                });
                
                // Update effects
                this.effects.forEach((effect, i) => {
                    effect.age += dt;
                    const progress = effect.age / effect.maxAge;
                    effect.particles.forEach(p => {
                        p.x += p.vx * dt * 0.1;
                        p.y += p.vy * dt * 0.1;
                        p.alpha = 1 - progress;
                    });
                    if (effect.age > effect.maxAge) this.effects.splice(i, 1);
                });
                
                // Check collisions
                if (!this.abilities.phase.active && !this.abilities.shield.active) {
                    this.obstacles.forEach(obs => {
                        if (this.checkCollision(this.player, obs)) this.gameOver();
                    });
                }
                
                // Check target collision
                if (this.target.visible && this.checkCollision(this.player, this.target)) {
                    this.levelComplete();
                }
                
                // Update UI
                this.updateUI();
                
                // Regenerate energy
                this.quantumEnergy = Math.min(100, this.quantumEnergy + dt * 0.02);
                this.coherence = Math.max(60, this.coherence - dt * 0.01);
            }

            checkCollision(obj1, obj2) {
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.sqrt(dx * dx + dy * dy) < obj1.radius + obj2.radius;
            }

            collectPowerup(pup) {
                this.score += 100;
                switch (pup.type) {
                    case 'energy': this.quantumEnergy = Math.min(100, this.quantumEnergy + 30); break;
                    case 'shield': this.abilities.shield.active = true; this.abilities.shield.duration = 2000; break;
                    case 'speed': this.coherence = Math.min(100, this.coherence + 20); break;
                }
                this.createEffect('collect', pup.x, pup.y);
            }

            levelComplete() {
                this.level++;
                this.score += 500 * this.level;
                this.gameState = 'levelcomplete';
                this.showNotification('QUANTUM STATE ACHIEVED!', `Level ${this.level - 1} complete! Score: ${Math.floor(this.score)}`);
            }

            nextLevel() {
                this.player.x = 80;
                this.player.y = this.canvas.height / 2;
                this.player.vx = 0;
                this.player.vy = 0;
                this.player.trail = [];
                this.player.clones = [];
                this.target.x = this.canvas.width - 80;
                this.target.y = this.canvas.height / 2;
                this.target.visible = true;
                this.generateLevel();
                this.gameState = 'playing';
                this.gameLoop();
            }

            gameOver() {
                this.gameState = 'gameover';
                this.showNotification('QUANTUM DECOHERENCE', `Wave function collapsed! Final Score: ${Math.floor(this.score)}`);
            }

            resetGame() {
                this.initGame();
                this.showMainMenu();
            }

            showNotification(title, text) {
                document.getElementById('notificationTitle').textContent = title;
                document.getElementById('notificationText').textContent = text;
                document.getElementById('notification').classList.add('show');
            }

            updateAbilityUI() {
                const btns = ['teleport', 'slowTime', 'shield', 'clone', 'magnet', 'phase', 'entangle', 'collapse'];
                btns.forEach(ability => {
                    const btn = document.getElementById(ability + 'Btn');
                    const ab = this.abilities[ability];
                    btn.classList.toggle('cooldown', ab.cd > 0 || this.quantumEnergy < 25);
                    btn.classList.toggle('active', ab.active || (ability === 'clone' && this.player.clones.length > 0));
                });
            }

            updateUI() {
                document.getElementById('scoreDisplay').textContent = Math.floor(this.score);
                document.getElementById('levelDisplay').textContent = this.level;
                document.getElementById('energyDisplay').textContent = Math.floor(this.quantumEnergy) + '%';
                document.getElementById('quantumFill').style.width = this.quantumEnergy + '%';
                document.getElementById('coherenceDisplay').textContent = Math.floor(this.coherence) + '%';
            }

            startBackgroundAnimation() {
                const animate = () => {
                    this.updateBackgroundParticles();
                    this.renderBackgroundParticles();
                    requestAnimationFrame(animate);
                };
                animate();
            }

            updateBackgroundParticles() {
                this.backgroundParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x < 0) p.x = window.innerWidth;
                    if (p.x > window.innerWidth) p.x = 0;
                    if (p.y < 0) p.y = window.innerHeight;
                    if (p.y > window.innerHeight) p.y = 0;
                    p.hue += 0.5;
                });
            }

            renderBackgroundParticles() {
                this.bgCtx.clearRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
                this.backgroundParticles.forEach(p => {
                    this.bgCtx.save();
                    this.bgCtx.globalAlpha = p.opacity;
                    this.bgCtx.fillStyle = `hsl(${p.hue}, 70%, 60%)`;
                    this.bgCtx.beginPath();
                    this.bgCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.bgCtx.fill();
                    this.bgCtx.restore();
                });
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.gameState !== 'playing') return;
                
                // Player trail
                this.player.trail.forEach(point => {
                    if (point.alpha > 0) {
                        this.ctx.save();
                        this.ctx.globalAlpha = point.alpha;
                        this.ctx.fillStyle = '#00ffff';
                        this.ctx.beginPath();
                        this.ctx.arc(point.x, point.y, this.player.radius * 0.3, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                });
                
                // Player wave function
                this.ctx.save();
                this.ctx.globalAlpha = 0.3;
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.radius + 10 + Math.sin(this.player.wavePhase) * 5, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.restore();
                
                // Player
                const gradient = this.ctx.createRadialGradient(this.player.x, this.player.y, 0, this.player.x, this.player.y, this.player.radius);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.7, '#00ffff');
                gradient.addColorStop(1, 'transparent');
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Shield effect
                if (this.abilities.shield.active) {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.6;
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x, this.player.y, this.player.radius + 15, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.restore();
                }
                
                // Clones
                this.player.clones.forEach(clone => {
                    this.ctx.save();
                    this.ctx.globalAlpha = clone.lifetime / 4000 * 0.6;
                    this.ctx.fillStyle = '#ff00ff';
                    this.ctx.beginPath();
                    this.ctx.arc(clone.x, clone.y, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
                
                // Obstacles
                this.obstacles.forEach(obs => {
                    this.ctx.save();
                    this.ctx.translate(obs.x, obs.y);
                    this.ctx.rotate(obs.rotation);
                    
                    if (obs.collapsing) this.ctx.globalAlpha = obs.collapseTime / 1000;
                    
                    const grad = this.ctx.createRadialGradient(0, 0, 0, 0, 0, obs.radius);
                    grad.addColorStop(0, '#000000');
                    grad.addColorStop(0.6, '#330000');
                    grad.addColorStop(1, '#ff0000');
                    this.ctx.fillStyle = grad;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, obs.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = '#ff6600';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, obs.radius + 5 + Math.sin(obs.pulsePhase) * 3, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.restore();
                });
                
                // Powerups
                this.powerups.forEach(pup => {
                    this.ctx.save();
                    this.ctx.translate(pup.x, pup.y);
                    this.ctx.rotate(pup.rotation);
                    
                    const colors = { energy: '#00ffff', shield: '#ffff00', speed: '#ff8000' };
                    const size = pup.radius + Math.sin(pup.pulsePhase) * 3;
                    
                    const grad = this.ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                    grad.addColorStop(0, '#ffffff');
                    grad.addColorStop(0.7, colors[pup.type]);
                    grad.addColorStop(1, 'transparent');
                    this.ctx.fillStyle = grad;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
                
                // Target
                if (this.target.visible) {
                    const size = this.target.radius + Math.sin(this.target.pulsePhase) * 5;
                    
                    const grad = this.ctx.createRadialGradient(this.target.x, this.target.y, 0, this.target.x, this.target.y, size * 2);
                    grad.addColorStop(0, 'rgba(0, 255, 0, 0.8)');
                    grad.addColorStop(0.5, 'rgba(0, 255, 0, 0.3)');
                    grad.addColorStop(1, 'transparent');
                    this.ctx.fillStyle = grad;
                    this.ctx.beginPath();
                    this.ctx.arc(this.target.x, this.target.y, size * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    for (let i = 0; i < 3; i++) {
                        this.ctx.strokeStyle = `rgba(0, 255, 0, ${1 - i * 0.3})`;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(this.target.x, this.target.y, size - i * 6, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                }
                
                // Effects
                this.effects.forEach(effect => {
                    effect.particles.forEach(p => {
                        if (p.alpha > 0) {
                            this.ctx.save();
                            this.ctx.globalAlpha = p.alpha;
                            this.ctx.fillStyle = '#00ffff';
                            this.ctx.beginPath();
                            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.restore();
                        }
                    });
                });
            }

            gameLoop() {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                if (this.gameState === 'playing') {
                    this.update(deltaTime);
                    this.render();
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }

            togglePause() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    this.showNotification('PAUSED', 'Press ESC to resume');
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    this.lastTime = performance.now(); // Reset timing to prevent delta spike
                    document.getElementById('notification').classList.remove('show');
                    // Don't call gameLoop() again - it will resume automatically
                }
            }
        }

        // Initialize game
        const game = new QuantumGame();
    </script>
</body>
</html>